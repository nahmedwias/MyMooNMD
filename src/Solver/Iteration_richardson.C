#include <Iteration_richardson.h>
#include <BlockFEMatrix.h>
#include <BlockVector.h>
#include <Iteration_jacobi.h>
#include <MooNMD_Io.h>

#ifdef _MPI
#include <ParFECommunicator3D.h>
#include <mpi.h>
#endif

// L - LinearOperator, V - Vector
template <class L, class V>
Iteration_richardson<L, V>::Iteration_richardson(
  std::shared_ptr<Preconditioner<V>> prec)
 : IterativeMethod<L, V>(prec, "Richardson")
{
  if(!prec)
  {
    ErrThrow("No preconditioner specified. Choose NoPreconditioner<Vector> if "
             "you don't need one");
  }
}

/* ************************************************************************** */
// L - LinearOperator, V - Vector
template <class L, class Vector>
std::pair<unsigned int, double> Iteration_richardson<L, Vector>::iterate(
  const L & A, const Vector & rhs, Vector & solution)
{

  //MPI: rhs and solution in consistency level 0 for computation of global norm

  Vector z(A, false);
  
#ifdef _MPI
  int size, my_rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);
  std::vector<const TParFECommunicator3D*> comms = A.get_communicators();
#endif

#ifndef _MPI
  double normb = norm(rhs);
#elif _MPI
  double normb = rhs.norm_global(comms);
#endif
  if (normb == 0.0)
    normb = 1;
  
#ifdef _MPI
  //MPI: solution in consistency level 2 for computation of global norm
  for (size_t bl = 0; bl < comms.size() ;++bl)
  {
    comms[bl]->consistency_update(solution.block(bl), 2);
  }
#endif

  //Vector r = rhs - A*solution;
  Vector r(rhs); // copy values
  A.apply_scaled_add(solution, r, -1.0);

  //MPI: Now r in consistency level 0
#ifndef _MPI
  double resid = norm(r) / normb;
#elif _MPI
  double resid = r.norm_global(comms) / normb;
#endif
  // safe initial residual, used to check stopping criteria later
  if(this->converged(resid, 0))
  {
    return std::pair<unsigned int, double>(0, resid);
  }
  
  for (unsigned int i = 1; i <= this->max_n_iterations; i++)
  {
    //z = M.solve(r);
    this->prec->apply(r, z);
    // update solution by w*z (w = damping factor)
    solution.add_scaled(z, this->damping);
    
    //r = b - A * x;
    r = rhs;
#ifdef _MPI
    //MPI: solution in consistency level 2 for computation of global norm
    for (size_t bl = 0; bl < comms.size() ;++bl)
    {
      comms[bl]->consistency_update(solution.block(bl), 2);
    }
#endif
    A.apply_scaled_add(solution, r, -1.0);

#ifndef _MPI
    resid = norm(r) / normb;
#elif _MPI
    resid = r.norm_global(comms) / normb;
#endif
    Output::print<4>("richardson iteration ", i, " ", resid);
    if(this->converged(resid, i))
    {
      return std::pair<unsigned int, double>(i, resid);
    }
  }
  // did not converge
  return std::pair<unsigned int, double>(this->max_n_iterations, resid);
}

/* ************************************************************************** */
// explicit instantiations
template class Iteration_richardson<BlockFEMatrix, BlockVector>;
// In MPI case we are so dependent on the connection of Matrix and FESpace, that
// it does not make sense to instantiate the function for BlockMatrix.
#ifndef _MPI
template class Iteration_richardson<BlockMatrix,   BlockVector>;
#endif
